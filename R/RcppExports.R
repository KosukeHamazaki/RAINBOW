# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Calculate aHinvb
#' @export
aHinvb_out <- function(a, b, u, ev) {
    .Call('_RAINBOW_aHinvb_out', PACKAGE = 'RAINBOW', a, b, u, ev)
}

#' Calculate aPb, aPPb, aPPPPb, tr(P), tr(PP) (and P)
#' @export
aPb_series_out <- function(a, b, u, ev, x) {
    .Call('_RAINBOW_aPb_series_out', PACKAGE = 'RAINBOW', a, b, u, ev, x)
}

#' Calculate log-likelihood
#' @export
llik_out <- function(n, p, logH, yPy, logXtX, logXtHinvX, REML = TRUE) {
    .Call('_RAINBOW_llik_out', PACKAGE = 'RAINBOW', n, p, logH, yPy, logXtX, logXtHinvX, REML)
}

#' Calculate the score function
score_func_out <- function(n, p, tr_HinvG, yPy, yPGPy, tr_PG, REML = TRUE) {
    .Call('_RAINBOW_score_func_out', PACKAGE = 'RAINBOW', n, p, tr_HinvG, yPy, yPGPy, tr_PG, REML)
}

#' Calculate the score function
#' @export
#'
hess_func_out <- function(n, p, tr_HinvG2, yPy, yPGPy, yPGPGPy, tr_PG2, REML = TRUE) {
    .Call('_RAINBOW_hess_func_out', PACKAGE = 'RAINBOW', n, p, tr_HinvG2, yPy, yPGPy, yPGPGPy, tr_PG2, REML)
}

#' Maximize likelihood when given lambda_0
#' @export
ml_est_out <- function(lambda, y, x, u, delta, z, k, logXtX, conv_param = 1e-06, count_max = 15L, bounds1 = 1e-06, bounds2 = 1e06, REML = TRUE) {
    .Call('_RAINBOW_ml_est_out', PACKAGE = 'RAINBOW', lambda, y, x, u, delta, z, k, logXtX, conv_param, count_max, bounds1, bounds2, REML)
}

#' Eigen decomposition via Rcpp
#' @export
eigen_out <- function(a, symmetric = TRUE, ainv = FALSE) {
    .Call('_RAINBOW_eigen_out', PACKAGE = 'RAINBOW', a, symmetric, ainv)
}

#' Calculate some values when given lambda
#' @export
ml_one_step <- function(lambda, y, x, u, delta, z, k, logXtX, conv_param = 1e-06, count_max = 15L, bounds1 = 1e-06, bounds2 = 1e06, REML = TRUE, SE = FALSE, return_Hinv = TRUE) {
    .Call('_RAINBOW_ml_one_step', PACKAGE = 'RAINBOW', lambda, y, x, u, delta, z, k, logXtX, conv_param, count_max, bounds1, bounds2, REML, SE, return_Hinv)
}

#' The spectral decomposition of G matrix (cholesky decomposition)
#' @export
spectralG_cholesky <- function(zbt, x, return_G = TRUE, return_SGS = FALSE) {
    .Call('_RAINBOW_spectralG_cholesky', PACKAGE = 'RAINBOW', zbt, x, return_G, return_SGS)
}

#' The spectral decomposition of G matrix (eigen decomposition)
#' @export
spectralG_eigen <- function(zkzt, x, return_G = TRUE, return_SGS = FALSE) {
    .Call('_RAINBOW_spectralG_eigen', PACKAGE = 'RAINBOW', zkzt, x, return_G, return_SGS)
}

#' Calculate Vu, Ve, LL and Hinv when given lambda
#' @export
EMM2_last_step <- function(lambda, y, x, u, d, z, k, th, ome_sq, ph, maxval, n, p, df, SE = FALSE, return_Hinv = FALSE) {
    .Call('_RAINBOW_EMM2_last_step', PACKAGE = 'RAINBOW', lambda, y, x, u, d, z, k, th, ome_sq, ph, maxval, n, p, df, SE, return_Hinv)
}

#' The kernel function of EM3.cpp
#' @export
EM3_kernel <- function(y0, X0, ZKZt0, S0, spI0, n, p, REML = TRUE) {
    .Call('_RAINBOW_EM3_kernel', PACKAGE = 'RAINBOW', y0, X0, ZKZt0, S0, spI0, n, p, REML)
}

#' Calculate P or Hinv, and log(P) or log(Hinv)
#' @export
P_calc <- function(lambda, Ws, Gammas, u, d, lw, Pornot = TRUE, gammas_diag = TRUE) {
    .Call('_RAINBOW_P_calc', PACKAGE = 'RAINBOW', lambda, Ws, Gammas, u, d, lw, Pornot, gammas_diag)
}

#' Calculate restricted log likelihood using P
#' @export
llik_REML <- function(n, p, yPy, lnP) {
    .Call('_RAINBOW_llik_REML', PACKAGE = 'RAINBOW', n, p, yPy, lnP)
}

#' Calculate log likelihood using P
#' @export
llik_ML <- function(n, yPy, lnHinv) {
    .Call('_RAINBOW_llik_ML', PACKAGE = 'RAINBOW', n, yPy, lnHinv)
}

#' Calculate first derivariate of the log-likelihood for score test
#' @export
score_l1 <- function(y, p0, Gs, lg) {
    .Call('_RAINBOW_score_l1', PACKAGE = 'RAINBOW', y, p0, Gs, lg)
}

#' Calculate first derivariate of the log-likelihood for score test (for linear kernel)
#' @export
score_l1_linker <- function(y, p0, Ws, Gammas, lw) {
    .Call('_RAINBOW_score_l1_linker', PACKAGE = 'RAINBOW', y, p0, Ws, Gammas, lw)
}

#' Calculate first derivariate of the log-likelihood for score test (for linear kernel)
#' @export
score_l1_linker_diag <- function(y, p0, W2s, lw) {
    .Call('_RAINBOW_score_l1_linker_diag', PACKAGE = 'RAINBOW', y, p0, W2s, lw)
}

#' Calculate fisher information of the log-likelihood for score test
#' @export
score_fisher <- function(p0, Gs_all, nuisance_no, lg_all) {
    .Call('_RAINBOW_score_fisher', PACKAGE = 'RAINBOW', p0, Gs_all, nuisance_no, lg_all)
}

#' Calculate fisher information of the log-likelihood for score test (for linear kernel)
#' @export
score_fisher_linker <- function(p0, Gs_all, Gammas, nuisance_no, lw_all) {
    .Call('_RAINBOW_score_fisher_linker', PACKAGE = 'RAINBOW', p0, Gs_all, Gammas, nuisance_no, lw_all)
}

#' Calculate fisher information of the log-likelihood for score test (for linear kernel)
#' @export
score_fisher_linker_diag <- function(p0, Gs_all, nuisance_no, lw_all) {
    .Call('_RAINBOW_score_fisher_linker_diag', PACKAGE = 'RAINBOW', p0, Gs_all, nuisance_no, lw_all)
}

#' Calculate statistic of GWAS which follows Beta distribution
#' @export
GWAS_F_test <- function(y, x, hinv, v1, v2, p) {
    .Call('_RAINBOW_GWAS_F_test', PACKAGE = 'RAINBOW', y, x, hinv, v1, v2, p)
}

